事务处理 是为了处理 类似于银行转账 甲方当向乙方转账 在转500这个操作下 存在2个原子操作 事务就是将其整合为一个操作

1．事务的特性ACID
		1）原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作		要么都发生，要么都不发生。 
		2）一致性（Consistency）一个事务中，事务前后数据的完整性必须保持一致。
		3）隔离性（Isolation）多个事务，事务的隔离性是指多个用户并发访问数据库时，			一个用户的	事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。
		4）持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变		就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

在开发过程中需要着重理解隔离性
  事务性数据库 都有4个隔离等级 从安全性从低到高依次排

  1）read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决
  2）read committed：读取已经提交的数据 ：可以解决脏读 ---- oracle默认的
  3）repeatable read：重读读取：可以解决脏读 和 不可重复读 ---mysql默认的
  4）serializable：串行化：可以解决 脏读 不可重复读 和 虚读---相当于锁表

  概念解释
    在mysql中 默认都是一个原子操作就是一个事务 即自动提交 当我们关掉了自动提交时 需要考虑在多个事务间 如果我更新一个表 那么在另一个事务里修改的表就是隔离性这个概念
    存在的地方
    有了以上的知识储备 我们可以理解：

     脏读 A事务做出相应改动没提交 B事务已经查询到了
     不可重复读 A事务即便更新了也提交了 但只要一开始读的是什么 之后还是什么 （有点迷糊 懒得写一遍）

-------------------------------------------------------------------------------------------------------------------------------

     API
        mysql操作
          start transaction
          commit
          rollback

        jdbc基本操作
          Connection conn
          开启事务：conn.setAutoComnmit(false);
          提交事务：conn.commit();
          回滚事务：conn.rollback();

    框架方面
       用web平台搭建一个转账平台 项目web19
       个人尝试 进行业务分析 配合三层架构 将dao web service 三个包中进行开发 最后也成功的跑起来
       缺陷 忽略了三层架构更深层的原理 dao层应当作为单一操作 而应当将判断余额这类问题 都交由
       service层负责处理

-------------------------------------------------------------------------------------------------------------------------------
    上述的利用的是事务开启与关闭在service层  但dao层的conn对像被调用在sercice层 为了符合逻辑 就要修改

    难点：线程池里面的线程都是随机拿的 因此你不能在dao层拿到他的对象
    解决方式： ThreadLocal 绑定资源 即维护一个Map 没有key 只有value key就是当前线程
    实现代码 见  MyDataBaseUtils

总结 ：
  很容易发现 这期在写笔记时 我已经不在注重代码了 随着学习的升入 代码都随业务变化而变化 而框架的原理与代码表现形式产生的原因成为了我关注的
对象  深层次探究三层架构如何搭建 而不是说照葫芦画瓢。


ps：代码跑不起来 改过了跑了几次就不行了 原因不明
